# 2026年1月26日 学习日志

## 1. RAG 进阶篇：长文本切片 (Chunking) 技术全解

### 1.核心算法 A：固定长度滑动窗口
```python
def get_chunks(text, chunk_size=200, overlap=50):
    """
    将长文本切分成带重叠部分的块
    chunk_size: 每个块的字数
    overlap: 相邻两个块重叠的字数（防止语义断裂）
    """
    chunks = []
    # 每次移动的步长 = 块大小 - 重叠大小
    step = chunk_size - overlap
    
    for i in range(0, len(text), step):
        # 切取当前片段
        chunk = text[i : i + chunk_size]
        chunks.append(chunk)
        
        # 如果已经到了文本末尾，就跳出
        if i + chunk_size >= len(text):
            break
            
    return chunks
```
**关键参数解析**
* **Chunk Size**：决定了 AI 每次看多少内容。太大则噪音多，太小则语义碎。
* **Overlap (重叠)**：充当语义“胶水”，防止人名、日期等关键实体在切分点被劈成两半，确保上下文衔接。
  
### 2.核心算法B：语义切分
这是一种更智能的“贪心算法”，优先考虑语言的自然停顿，而非死板的字数。
```python
def get_chunks_by_sentence(text, chunk_size=300):
    # 第一步：切割——将长文拆成独立的语义单元
    sentences = text.split('。') 
    
    chunks = []          # 最终的“抽屉”，存放切好的块
    current_chunk = ""   # 当前正在填满的“临时篮子”
    
    # 第二步：组装——根据容量（chunk_size）装箱
    for sentence in sentences:
        # 如果“篮子里的内容” + “新的一句”没有超过上限
        if len(current_chunk) + len(sentence) <= chunk_size:
            current_chunk += sentence + "。" # 塞进去，并补回被 split 掉的句号
        else:
            # 如果塞不下了，就把现在的“篮子”封好存入列表
            chunks.append(current_chunk)
            # 开一个新篮子，把这句放不下的句子作为新篮子的开头
            current_chunk = sentence + "。"
            
    # 第三步：收尾——处理最后剩下的内容————防御型收尾
    if current_chunk:
        chunks.append(current_chunk)
        
    return chunks
```
**核心算法思维：贪心策略 (Greedy Approach)**
这段代码体现了算法中常见的贪心思想：
* **尽可能多装**：只要没达到 ``chunk_size``，就不断把句子往当前的块里塞。
* **语义优先**:它宁愿让一个块只有 250 字，也不会为了凑满 300 字而把下一个句子切断。

**语义切分优势**
* **1.保证原子性**：在向量检索（Vector Search）中，模型对完整句子的理解远高于碎片。 这种写法确保了检索出来的每一段话至少在句法上是完整的。
* **2.动态长度适应**：固定长度切分是“死”的，而语义切分是“活”的。 它可以根据句子的长短自动调整块的大小，避免了无效信息的截断。

### 3.核心算法C：多标点语义切分

```python
import re

def get_chunks_ultimate(text, chunk_size=400):
    """
    【旗舰版】多标点语义切分
    支持：句号、感叹号、问号、换行符
    """
    # 1. 使用正则表达式同时匹配多种分隔符
    # [。！？\n] 表示匹配这四个中的任意一个，括号 () 表示保留分隔符本身
    sentences = re.split(r'([。！？\n])', text)
    
    # 因为 re.split 会把分隔符单独分出来，我们需要把它们拼回去
    # 比如：["你好", "！"] -> ["你好！"]
    combined_sentences = []
    for i in range(0, len(sentences) - 1, 2):
        combined_sentences.append(sentences[i] + sentences[i+1])
    
    # 处理最后可能多出来的文本（如果没有匹配到分隔符）
    if len(sentences) % 2 != 0:
        combined_sentences.append(sentences[-1])

    chunks = []
    current_chunk = ""
    
    # 2. 贪心装箱逻辑
    for sentence in combined_sentences:
        if len(current_chunk) + len(sentence) <= chunk_size:
            current_chunk += sentence
        else:
            if current_chunk:
                chunks.append(current_chunk)
            current_chunk = sentence
            
    # 3. 边界防御：收尾工作
    if current_chunk:
        chunks.append(current_chunk)
        
    return chunks
```

#### 1. 技术栈升级
* 引入 Python `re` 模块，利用正则表达式实现多维度语义边界识别。
* 采用“捕获组”技术，在切分的同时完整保留文本的标点语气。

#### 2. 解决的痛点
* **语义丢失**：解决了单一标点切分导致感叹句、疑问句语义被忽视的问题。
* **格式断裂**：通过识别 `\n`，自动对齐原始文档的段落逻辑。

#### 3. 算法工程师笔记
* **贪心装箱 (Greedy Packing)**：虽然引入了复杂拆分，但核心重组逻辑依然遵循“尽可能多装”的原则，保证了 Token 的利用率。
* **防御性策略**：针对 `re.split` 产生的尾部奇数元素进行了专项处理，确保全量数据无损摄入。

### 专项总结：正则表达式 (Regex) 在 AI 数据清洗中的应用

#### 1. 基础原语
* **字符集 `[]`**: 定义匹配范围（如 `[0-9]` 匹配数字，相当于`\d`;`[a-z]`匹配小写字母;`[A-Z]`匹配大写字母;`[abc]`匹配`a`或`b`或`c`）。
* **量词 `+` / `*`**: 定义重复次数。
* **分组 `()`**: 实现提取与保留，是 `re.split` 语义切分的核心。
* **位数**：例如`re.findall(r'\d+', "2026年有12个月")`能返回2026，12；`re.findall(r'1[3-9]\d{9}', text)`能提取手机号，`\d{9}`代表九位数。

#### 2. RAG 场景实战
* **语义保留切分**: `re.split(r'([。！？\n])', text)` 确保标点不丢失。
* **噪音过滤**: 利用 `re.sub` 剔除文档中的乱码、广告链接等干扰信息。

#### 3. 开发规范
* 始终使用 **Raw String (`r''`)** 编写正则，避免反斜杠转义陷阱。
* 对于复杂的正则，应先在 [regex101.com](https://regex101.com) 等工具上调试后再接入代码。

### 正则实战：结构化数据提取

#### 1. 任务背景
从非结构化文本中精准提取 YYYY-MM-DD 格式日期，过滤掉非标准格式（如 2026/01/24）或异常数字。

#### 2. 核心技术
* **模式匹配**：`r'\d{4}-\d{2}-\d{2}'`。
* **量词控制**：利用 `{n}` 实现固定长度的约束，增强匹配的精确度。
* **API 调用**：`re.findall()` 实现全量扫描并以列表形式返回结果。

#### 3. 工程思考
在 RAG 的预处理阶段，正则提取可用于：
* **元数据提取**：自动识别文档发布时间。
* **脱敏处理**：定位并打码敏感信息（如手机号、身份证号）。

#### Python `re` 模块常用函数指南

##### 1. 提取类：`re.findall()`
* **特性**：非阻塞式全量扫描，返回 `list[str]`。
* **应用**：RAG 预处理阶段的实体（Entity）识别。

##### 2. 变换类：`re.sub()` 与 `re.split()`
* **`re.sub()`**: `sub`是 "substitute" (替换) 的缩写。它是 RAG 数据脱敏和噪音剔除的神器。
  代码示例：
  
```python
# 把所有数字换成 X
re.sub(r'\d', 'X', "我的学号是12345") 
# 返回: "我的学号是XXXXX"
```
* **`re.split()`**: 复杂文本切分逻辑的基础，支持捕获组保留分隔符。

##### 3. 匹配对象：`re.search()`
* **注意**：返回的是 Match Object。需使用 `.group()` 获取具体内容，使用 `.start()` / `.end()` 获取位置信息。